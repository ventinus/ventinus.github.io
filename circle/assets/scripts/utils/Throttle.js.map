{"version":3,"sources":["../../../../src/assets/scripts/utils/Throttle.js"],"names":[],"mappings":";;;AAAA,GAAC,UAAS,CAAC,EAAC,MAAM,EAAC,SAAS,EAAC;AAC3B,eAAW,CAAC;;;;;AAKZ,QAAI,CAAC,GAAG,MAAM,CAAC,MAAM,IAAI,MAAM,CAAC,MAAM,KAAM,MAAM,CAAC,MAAM,GAAG,EAAE,CAAA,AAAE;;;AAG9D,eAAW,CAAC;;AAGd,KAAC,CAAC,QAAQ,GAAG,WAAW,GAAG,UAAU,KAAK,EAAE,WAAW,EAAE,QAAQ,EAAE,aAAa,EAAG;;;;AAIjF,UAAI,UAAU;;;AAGZ,eAAS,GAAG,CAAC,CAAC;;;AAGhB,UAAK,OAAO,WAAW,KAAK,SAAS,EAAG;AACtC,qBAAa,GAAG,QAAQ,CAAC;AACzB,gBAAQ,GAAG,WAAW,CAAC;AACvB,mBAAW,GAAG,SAAS,CAAC;OACzB;;;;;AAKD,eAAS,OAAO,GAAG;AACjB,YAAI,IAAI,GAAG,IAAI;YACb,OAAO,GAAG,CAAC,IAAI,IAAI,EAAE,GAAG,SAAS;YACjC,IAAI,GAAG,SAAS,CAAC;;;AAGnB,iBAAS,IAAI,GAAG;AACd,mBAAS,GAAG,CAAC,IAAI,IAAI,EAAE,CAAC;AACxB,kBAAQ,CAAC,KAAK,CAAE,IAAI,EAAE,IAAI,CAAE,CAAC;SAC9B,CAAC;;;;AAIF,iBAAS,KAAK,GAAG;AACf,oBAAU,GAAG,SAAS,CAAC;SACxB,CAAC;;AAEF,YAAK,aAAa,IAAI,CAAC,UAAU,EAAG;;;AAGlC,cAAI,EAAE,CAAC;SACR;;;AAGD,kBAAU,IAAI,YAAY,CAAE,UAAU,CAAE,CAAC;;AAEzC,YAAK,aAAa,KAAK,SAAS,IAAI,OAAO,GAAG,KAAK,EAAG;;;AAGpD,cAAI,EAAE,CAAC;SAER,MAAM,IAAK,WAAW,KAAK,IAAI,EAAG;;;;;;;;;;AAUjC,oBAAU,GAAG,UAAU,CAAE,aAAa,GAAG,KAAK,GAAG,IAAI,EAAE,aAAa,KAAK,SAAS,GAAG,KAAK,GAAG,OAAO,GAAG,KAAK,CAAE,CAAC;SAChH;OACF,CAAC;;;;;AAKF,UAAK,CAAC,CAAC,IAAI,EAAG;AACZ,eAAO,CAAC,IAAI,GAAG,QAAQ,CAAC,IAAI,GAAG,QAAQ,CAAC,IAAI,IAAI,CAAC,CAAC,IAAI,EAAE,CAAC;OAC1D;;;AAGD,aAAO,OAAO,CAAC;KAChB,CAAC;GAIH,CAAA,CAAE,MAAM,CAAC,KAAK,IAAI,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC","file":"Throttle.js","sourcesContent":["(function($,window,undefined){\n  '$:nomunge'; // Used by YUI compressor.\n  \n  // Since jQuery really isn't required for this plugin, use `jQuery` as the\n  // namespace only if it already exists, otherwise use the `Cowboy` namespace,\n  // creating it if necessary.\n  var $ = window.jQuery || window.Cowboy || ( window.Cowboy = {} ),\n    \n    // Internal method reference.\n    jq_throttle;\n\n  \n  $.throttle = jq_throttle = function( delay, no_trailing, callback, debounce_mode ) {\n    // After wrapper has stopped being called, this timeout ensures that\n    // `callback` is executed at the proper times in `throttle` and `end`\n    // debounce modes.\n    var timeout_id,\n      \n      // Keep track of the last time `callback` was executed.\n      last_exec = 0;\n    \n    // `no_trailing` defaults to falsy.\n    if ( typeof no_trailing !== 'boolean' ) {\n      debounce_mode = callback;\n      callback = no_trailing;\n      no_trailing = undefined;\n    }\n    \n    // The `wrapper` function encapsulates all of the throttling / debouncing\n    // functionality and when executed will limit the rate at which `callback`\n    // is executed.\n    function wrapper() {\n      var that = this,\n        elapsed = +new Date() - last_exec,\n        args = arguments;\n      \n      // Execute `callback` and update the `last_exec` timestamp.\n      function exec() {\n        last_exec = +new Date();\n        callback.apply( that, args );\n      };\n      \n      // If `debounce_mode` is true (at_begin) this is used to clear the flag\n      // to allow future `callback` executions.\n      function clear() {\n        timeout_id = undefined;\n      };\n      \n      if ( debounce_mode && !timeout_id ) {\n        // Since `wrapper` is being called for the first time and\n        // `debounce_mode` is true (at_begin), execute `callback`.\n        exec();\n      }\n      \n      // Clear any existing timeout.\n      timeout_id && clearTimeout( timeout_id );\n      \n      if ( debounce_mode === undefined && elapsed > delay ) {\n        // In throttle mode, if `delay` time has been exceeded, execute\n        // `callback`.\n        exec();\n        \n      } else if ( no_trailing !== true ) {\n        // In trailing throttle mode, since `delay` time has not been\n        // exceeded, schedule `callback` to execute `delay` ms after most\n        // recent execution.\n        // \n        // If `debounce_mode` is true (at_begin), schedule `clear` to execute\n        // after `delay` ms.\n        // \n        // If `debounce_mode` is false (at end), schedule `callback` to\n        // execute after `delay` ms.\n        timeout_id = setTimeout( debounce_mode ? clear : exec, debounce_mode === undefined ? delay - elapsed : delay );\n      }\n    };\n    \n    // Set the guid of `wrapper` function to the same of original callback, so\n    // it can be removed in jQuery 1.4+ .unbind or .die by using the original\n    // callback as a reference.\n    if ( $.guid ) {\n      wrapper.guid = callback.guid = callback.guid || $.guid++;\n    }\n    \n    // Return the wrapper function.\n    return wrapper;\n  };\n  \n\n  \n})(window.Zepto || window.jQuery, window);\n"]}